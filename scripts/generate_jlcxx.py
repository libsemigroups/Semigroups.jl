#!/usr/bin/env python3
"""
This module partially generates JlCxx (CxxWrap.jl) bindings from the doxygen
output in docs/xml. It reuses the Doxygen XML parsing logic from
generate_pybind11.py and rewrites the code generation layer for JlCxx patterns.
"""
# pylint: disable=missing-docstring

import re
import sys
import argparse

from os.path import isfile, exists
from functools import cache
from glob import glob
from accepts import accepts

import bs4
from bs4 import BeautifulSoup

__DOXY_DICT = {}
__ABSTRACT_CLASSES = {}

########################################################################
# Copyright / Headers / Footers
########################################################################

__COPYRIGHT = """//
// Semigroups.jl
// Copyright (C) 20XX TODO
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//
"""

__HEADERS = """
#include "libsemigroups_julia.hpp"
// #include <libsemigroups/TODO.hpp>
// TODO: add the appropriate libsemigroups header

"""

__FOOTER = """
}    // namespace libsemigroups_julia
"""

__DOXY_DIR = None

########################################################################
# Internal helpers
########################################################################


def __error(msg: str) -> None:
    sys.stderr.write(f"\033[0;31m{msg}\n\033[0m")


def __bold(msg: str) -> None:
    sys.stderr.write(f"\033[1m{msg}\n\033[0m")


def __parse_args() -> argparse.Namespace:
    global __DOXY_DIR
    parser = argparse.ArgumentParser(prog="generate_jlcxx", usage="%(prog)s [options]")
    parser.add_argument(
        "things",
        nargs="+",
        help="the things (classes, structs, namespaces) to create bindings for",
    )
    parser.add_argument(
        "--no-advice",
        dest="no_advice",
        default=False,
        action="store_true",
        help="use this flag to disable the advice at the end of the script",
    )
    parser.add_argument(
        "--doxy-dir",
        nargs=1,
        type=str,
        default="docs/xml",
        help="the path to the xml generated by Doxygen",
    )
    parser.add_argument(
        "--no-header-footer",
        dest="no_header_footer",
        default=False,
        action="store_true",
        help="use this flag to disable the file header and footer",
    )
    args = parser.parse_args()
    __DOXY_DIR = args.doxy_dir[0]
    __bold(f'Finding doxygen xml output in "{__DOXY_DIR}" . . .')
    return args


########################################################################
# Doxygen XML parsing (adapted from generate_pybind11.py)
########################################################################


@cache
@accepts(str)
def doxygen_filename(thing: str) -> str:
    orig = thing
    thing = re.sub("_", "__", thing)
    if thing.endswith("_group"):
        fname = f"{__DOXY_DIR}/group__{thing}.xml"
        if exists(fname) and isfile(fname):
            return fname
    p = re.compile(r"::")
    thing = p.sub("_1_1", thing)
    # Try Doxygen CamelCase encoding first: insert _ before uppercase,
    # lowercase all. This avoids accidentally matching a namespace file
    # when a class was intended (e.g. BMat8 class vs bmat8 namespace).
    thing_doxy = re.sub(r"([A-Z])", lambda m: "_" + m.group(1).lower(), thing)
    for possible in ("class", "struct"):
        fname = f"{__DOXY_DIR}/{possible}{thing_doxy}.xml"
        if exists(fname) and isfile(fname):
            return fname
    # Try exact match for class/struct/namespace
    for possible in ("class", "struct", "namespace"):
        fname = f"{__DOXY_DIR}/{possible}{thing}.xml"
        if exists(fname) and isfile(fname):
            return fname
    # Try CamelCase encoding for namespace
    for possible in ("namespace",):
        fname = f"{__DOXY_DIR}/{possible}{thing_doxy}.xml"
        if exists(fname) and isfile(fname):
            return fname
    # Fall back to group files
    thing = thing.split("_1_1")[-1]
    pattern = re.compile(rf">{thing}<")
    for fname in glob(f"{__DOXY_DIR}/group__*.xml"):
        with open(fname, "r", encoding="utf-8") as file:
            lines = file.read()
        if pattern.search(lines):
            return fname
    __error(f'Can\'t find the doxygen file for "{orig}" IGNORING!!!')
    return ""


@accepts(str, str | None, str | None)
def get_xml(
    thing: str, fn: str | None = None, params_t: str | None = None
) -> dict[str, bs4.element.Tag]:
    if thing not in __DOXY_DICT:
        with open(doxygen_filename(thing), "r", encoding="utf-8") as xml:
            xml = BeautifulSoup(xml, "xml")
            compounddefs = xml.find_all("compounddef")

            for compounddef in compounddefs:
                if "abstract" in compounddef.attrs and compounddef["abstract"] == "yes":
                    __ABSTRACT_CLASSES[thing] = True
            fn_list = xml.find_all("memberdef")
            fn_dict = {}

            for x in fn_list:
                nm = x.find("name").text
                if nm not in fn_dict:
                    fn_dict[nm] = {}
                tparam = x.find("templateparamlist")
                if tparam is not None:
                    tparam = tparam.find_all("param")
                    tparam = [x.find("type").text.strip() for x in tparam]
                param = x.find_all("param")
                param = [x.find("type").text.strip() for x in param]
                if tparam is not None:
                    param = [x for x in param if x not in tparam]
                param = ",".join(param)

                fn_dict[nm][param] = x
            __DOXY_DICT[thing] = fn_dict
    if fn is not None:
        if params_t == "" and len(__DOXY_DICT[thing][fn]) == 1:
            return list(__DOXY_DICT[thing][fn].values())[0]
        if params_t is not None:
            return __DOXY_DICT[thing][fn][params_t]
        return __DOXY_DICT[thing][fn]
    return __DOXY_DICT[thing]


########################################################################
# Query functions (from generate_pybind11.py)
########################################################################


@cache
@accepts(str, str, str)
def is_public(thing: str, fn: str, params_t: str) -> bool:
    if is_namespace(thing):
        return True
    xml = get_xml(thing, fn, params_t)
    prot = xml.get("prot")
    return prot is not None and prot == "public"


@cache
@accepts(str, str, str)
def is_enum(thing: str, fn: str, params_t: str) -> bool:
    xml = get_xml(thing, fn, params_t)
    kind = xml.get("kind")
    return kind is not None and kind == "enum"


@cache
@accepts(str, str, str)
def is_typedef(thing: str, fn: str, params_t: str) -> bool:
    xml = get_xml(thing, fn, params_t)
    kind = xml.get("kind")
    return kind is not None and kind == "typedef"


@cache
@accepts(str)
def class_template_params(thing: str) -> list[str]:
    result = []
    doxy_file = doxygen_filename(thing)
    if is_namespace(thing) or not doxy_file:
        return result
    with open(doxy_file, "r", encoding="utf-8") as xml:
        xml = BeautifulSoup(xml, "xml")
        for x in xml.doxygen.compounddef.children:
            if x.name == "templateparamlist":
                for y in x.find_all("param"):
                    result.append(y.find("type").text)
                    if y.find("declname") is not None:
                        result[-1] += " " + y.find("declname").text
    return result


@cache
@accepts(str)
def is_class_template(thing: str) -> bool:
    return len(class_template_params(thing)) != 0


@cache
@accepts(str, str)
def is_overloaded(thing: str, fn: str) -> bool:
    return len(get_xml(thing, fn)) > 1


@cache
@accepts(str)
def is_namespace(thing: str) -> bool:
    return "namespace" in doxygen_filename(thing)


@cache
@accepts(str)
def is_free_fn(thing: str) -> bool:
    return doxygen_filename(thing).startswith(f"{__DOXY_DIR}/group__")


@cache
@accepts(str, str, str)
def is_static_mem_fn(thing: str, fn: str, params_t: str) -> bool:
    if is_namespace(thing) or is_free_fn(thing):
        return False
    xml = get_xml(thing, fn, params_t)
    return xml["static"] == "yes"


@cache
@accepts(str)
def is_abstract_class(thing: str) -> bool:
    return thing in __ABSTRACT_CLASSES


@cache
@accepts(str, str, str)
def params_dict(thing: str, fn: str, params_t: str) -> dict[str, str]:
    xml = get_xml(thing, fn, params_t)
    result = {}
    for x in xml.find_all("param"):
        type_ = x.find("type").text
        if not type_.startswith("typename"):
            name = x.find("declname")
            if name:
                result[name.text] = type_
    return result


@cache
@accepts(str, str, str)
def return_type(thing: str, fn: str, params_t: str) -> str:
    xml = get_xml(thing, fn, params_t)
    return xml.find("type").text


@accepts(str, str, str)
def param_names_str(thing: str, fn: str, params_t: str) -> list[str]:
    return list(params_dict(thing, fn, params_t).keys())


@accepts(str, str, str)
def fn_sig(thing: str, fn: str, params_t: str) -> list[str]:
    params_d = params_dict(thing, fn, params_t)
    result = []
    for name, type_ in params_d.items():
        result.append(f"{type_} {name}")
    return result


@accepts(str)
def shortname(thing: str) -> str:
    if thing.startswith("libsemigroups::"):
        return thing[len("libsemigroups::") :]
    return thing


@accepts(str)
def shortname_(thing: str) -> str:
    name = shortname(thing)
    if is_class_template(thing):
        name += "_"
    return name


@cache
@accepts(str, str, str)
def is_const_mem_fn(thing: str, fn: str, params_t: str) -> bool:
    if is_namespace(thing):
        return False
    xml = get_xml(thing, fn, params_t)
    assert "const" in xml.attrs, "const not an attribute!"
    return xml["const"] == "yes"


@cache
@accepts(str, str, str)
def is_deleted_mem_fn(class_n: str, mem_fn: str, params_t: str) -> bool:
    xml = get_xml(class_n, mem_fn, params_t)
    if xml.find("argsstring") is None:
        return False
    return xml.find("argsstring").text.find("=delete") != -1


@cache
@accepts(str, str)
def is_constructor(class_n: str, mem_fn: str) -> bool:
    return not is_free_fn(class_n) and mem_fn.startswith(class_n.split("::")[-1])


@cache
@accepts(str, str)
def is_operator(_: str, mem_fn: str) -> bool:
    return mem_fn.startswith("operator") or mem_fn in ("at", "hash_value")


@cache
@accepts(str, str)
def is_iterator(_: str, mem_fn: str) -> bool:
    # Only use cbegin to avoid duplicate with begin
    return mem_fn.startswith("cbegin")


########################################################################
# JlCxx code generation
########################################################################

# Operator name mapping for JlCxx
__JLCXX_OPERATOR_MAP = {
    "operator==": "is_equal",
    "operator!=": "is_not_equal",
    "operator<": "is_less",
    "operator>": "is_greater",
    "operator<=": "is_less_equal",
    "operator>=": "is_greater_equal",
    "operator*": "multiply",
    "operator*=": "multiply!",
    "operator+": "add",
    "operator+=": "add!",
    "at": "at",
    "hash_value": "hash",
}


def translate_cpp_operator_to_jlcxx(mem_fn: str) -> str:
    if mem_fn in __JLCXX_OPERATOR_MAP:
        return __JLCXX_OPERATOR_MAP[mem_fn]
    __error(f"Unknown operator {mem_fn}")
    return mem_fn


def jlcxx_type_decl(thing: str) -> str:
    if is_namespace(thing) or is_free_fn(thing):
        return ""
    sn = shortname(thing)
    if is_class_template(thing):
        return f"  auto type = m.add_type<TType>(name);\n"
    return f'  auto type = m.add_type<{sn}>("{sn}");\n'


def jlcxx_is_mirrored_type(thing: str) -> str:
    """Generate IsMirroredType specialization for non-template classes."""
    if is_namespace(thing) or is_free_fn(thing) or is_class_template(thing):
        return ""
    return f"""// Disable CxxWrap mirroring for {shortname(thing)}
namespace jlcxx {{
template <> struct IsMirroredType<libsemigroups::{shortname(thing)}> : std::false_type {{}};
}}    // namespace jlcxx

"""


def jlcxx_constructor(thing: str, fn: str, params_t: str) -> str:
    assert is_constructor(thing, fn)
    if is_abstract_class(thing):
        return ""
    sn = shortname(thing)
    sn_ = shortname_(thing)

    if is_class_template(thing):
        type_name = "TType"
        sn = "TType"
        sn_ = "TType"
    else:
        type_name = sn

    # Skip copy constructor (same type const ref with no named param)
    class_short = thing.split("::")[-1]
    if params_t == f"{class_short} const &":
        return ""

    # Default constructor (no params)
    if not params_t:
        return f"  type.constructor<>();\n"

    # Parameterized constructor: use lambda on module
    sig = fn_sig(thing, fn, params_t)
    param_n = ", ".join(param_names_str(thing, fn, params_t))

    if is_class_template(thing):
        params_t_sub = re.sub(shortname(thing), "TType", params_t)
        sig = fn_sig(thing, fn, params_t)
        # Replace the class name in the signature with TType
        sig = [re.sub(shortname(thing), "TType", s) for s in sig]
        sig_str = ", ".join(sig)
        return (
            f"  m.method(type_name, []({sig_str}) -> {sn_} {{\n"
            f"    return {sn_}({param_n});\n"
            f"  }});\n"
        )
    else:
        sig_str = ", ".join(sig)
        return (
            f'  m.method("{sn}", []({sig_str}) -> {sn} {{\n'
            f"    return {sn}({param_n});\n"
            f"  }});\n"
        )


def jlcxx_operator(thing: str, fn: str, params_t: str) -> str:
    assert is_operator(thing, fn)
    sn_ = shortname_(thing)
    jl_name = translate_cpp_operator_to_jlcxx(fn)

    if is_class_template(thing):
        sn_ = "TType"

    # Comparison operators (binary, returning bool)
    if fn in (
        "operator==",
        "operator!=",
        "operator<",
        "operator>",
        "operator<=",
        "operator>=",
    ):
        return (
            f'  type.method("{jl_name}", '
            f"[]({sn_} const & a, {sn_} const & b) -> bool {{\n"
            f"    return a {fn[len('operator') :]} b;\n"
            f"  }});\n"
        )

    # Arithmetic operators (binary)
    if fn in ("operator*", "operator+"):
        op = fn[len("operator") :]
        sig = fn_sig(thing, fn, params_t)
        param_n = param_names_str(thing, fn, params_t)
        if sig:
            # Member operator: self is implicit, params are the RHS
            rhs_sig = ", ".join(sig)
            rhs_names = ", ".join(param_n)
            return (
                f'  type.method("{jl_name}", '
                f"[]({sn_} const & self, {rhs_sig}) {{\n"
                f"    return self {op} {rhs_names};\n"
                f"  }});\n"
            )
        return (
            f'  type.method("{jl_name}", '
            f"[]({sn_} const & a, {sn_} const & b) {{\n"
            f"    return a {op} b;\n"
            f"  }});\n"
        )

    # In-place operators
    if fn in ("operator*=", "operator+="):
        op = fn[len("operator") :]
        sig = fn_sig(thing, fn, params_t)
        param_n = param_names_str(thing, fn, params_t)
        if sig:
            rhs_sig = ", ".join(sig)
            rhs_names = ", ".join(param_n)
            return (
                f'  type.method("{jl_name}", '
                f"[]({sn_} & self, {rhs_sig}) {{\n"
                f"    self {op} {rhs_names};\n"
                f"  }});\n"
            )
        return (
            f'  type.method("{jl_name}", '
            f"[]({sn_} & self, {sn_} const & other) {{\n"
            f"    self {op} other;\n"
            f"  }});\n"
        )

    # at (element access)
    if fn == "at":
        sig = fn_sig(thing, fn, params_t)
        param_n = ", ".join(param_names_str(thing, fn, params_t))
        sig_str = ", ".join([f"{sn_} const & self"] + sig)
        return (
            f'  type.method("{jl_name}", '
            f"[]({sig_str}) {{\n"
            f"    return self.at({param_n});\n"
            f"  }});\n"
        )

    # hash_value
    if fn == "hash_value":
        return f'  type.method("{jl_name}", &{sn_}::hash_value);\n'

    __error(f"Unhandled operator: {fn}")
    return f"  // TODO: operator {fn}\n"


def jlcxx_iterator(thing: str, fn: str, params_t: str) -> str:
    assert is_iterator(thing, fn)
    sn_ = shortname_(thing)
    if is_class_template(thing):
        sn_ = "TType"

    # Determine suffix for naming
    pos = fn.find("_")
    suffix = fn[pos:] if pos != -1 else ""
    jl_name = f"images_vector{suffix}" if suffix else "images_vector"

    param_n = ", ".join(param_names_str(thing, fn, params_t))
    sig = fn_sig(thing, fn, params_t)

    if sig:
        sig_str = ", ".join([f"{sn_} const & self"] + sig)
    else:
        sig_str = f"{sn_} const & self"

    # Use begin/end naming
    if fn.startswith("begin"):
        end_fn = f"end{fn[5:]}"
    else:
        end_fn = f"cend{fn[6:]}"

    call_args = f"({param_n})" if param_n else "()"

    return (
        f'  type.method("{jl_name}", []({sig_str}) {{\n'
        f"    std::vector<typename {sn_}::value_type> result;\n"
        f"    for (auto val : self) {{\n"
        f"      result.push_back(val);\n"
        f"    }}\n"
        f"    return result;\n"
        f"  }});\n"
    )


def jlcxx_enum(thing: str, fn: str, params_t: str) -> str:
    assert is_enum(thing, fn, params_t)
    enum_cpp_name = f"{shortname(thing)}::{fn}"
    result = f'  m.add_bits<{enum_cpp_name}>("{fn}", jl::julia_type("CppEnum"));\n'
    xml = get_xml(thing, fn, params_t)
    for enum_val in xml.find_all("enumvalue"):
        name = enum_val.find("name").text
        result += f'  m.set_const("{fn}_{name}", {enum_cpp_name}::{name});\n'
    return result


def jlcxx_static_method(thing: str, fn: str, params_t: str) -> str:
    sn = shortname(thing)
    sn_ = shortname_(thing)

    if is_class_template(thing):
        sn_ = "TType"

    sig = fn_sig(thing, fn, params_t)
    param_n = ", ".join(param_names_str(thing, fn, params_t))

    if is_class_template(thing):
        sig = [re.sub(shortname(thing), "TType", s) for s in sig]

    # Use SingletonType pattern for static methods
    if sig:
        sig_str = ", ".join([f"jlcxx::SingletonType<{sn_}>"] + sig)
    else:
        sig_str = f"jlcxx::SingletonType<{sn_}>"

    call_args = f"({param_n})" if param_n else "()"

    return (
        f'  m.method("{fn}", []({sig_str}) {{\n'
        f"    return {sn_}::{fn}{call_args};\n"
        f"  }});\n"
    )


def jlcxx_free_fn(thing: str, fn: str, params_t: str) -> str:
    """Generate a free/namespace function binding."""
    sig = fn_sig(thing, fn, params_t)
    param_n = ", ".join(param_names_str(thing, fn, params_t))
    sig_str = ", ".join(sig)

    # Use simple name (no namespace prefix) - Julia dispatch handles it
    simple_name = fn.split("::")[-1] if "::" in fn else fn

    return (
        f'  m.method("{simple_name}", []({sig_str}) {{\n'
        f"    return {fn}({param_n});\n"
        f"  }});\n"
    )


def jlcxx_instance_method(thing: str, fn: str, params_t: str) -> str:
    """Generate an instance method binding."""
    sn_ = shortname_(thing)
    if is_class_template(thing):
        sn_ = "TType"

    # Non-overloaded: use direct pointer
    if not is_overloaded(thing, fn):
        return f'  type.method("{fn}", &{sn_}::{fn});\n'

    # Overloaded: use lambda
    sig = fn_sig(thing, fn, params_t)
    param_n = ", ".join(param_names_str(thing, fn, params_t))

    if is_const_mem_fn(thing, fn, params_t):
        self_param = f"{sn_} const & self"
    else:
        self_param = f"{sn_} & self"

    if sig:
        sig_str = ", ".join([self_param] + sig)
    else:
        sig_str = self_param

    call_args = f"({param_n})" if param_n else "()"

    return (
        f'  type.method("{fn}", []({sig_str}) {{\n'
        f"    return self.{fn}{call_args};\n"
        f"  }});\n"
    )


@accepts(str, str, str)
def jlcxx_fn(thing: str, fn: str, params_t: str) -> str:
    """Route to the appropriate JlCxx generator for a single function."""
    if is_enum(thing, fn, params_t) and is_public(thing, fn, params_t):
        return jlcxx_enum(thing, fn, params_t)

    if is_constructor(thing, fn):
        return jlcxx_constructor(thing, fn, params_t)

    if is_operator(thing, fn):
        return jlcxx_operator(thing, fn, params_t)

    if is_iterator(thing, fn):
        return jlcxx_iterator(thing, fn, params_t)

    if is_static_mem_fn(thing, fn, params_t):
        return jlcxx_static_method(thing, fn, params_t)

    if is_namespace(thing) or is_free_fn(thing):
        return jlcxx_free_fn(thing, fn, params_t)

    return jlcxx_instance_method(thing, fn, params_t)


########################################################################
# Skip logic (adapted from pybind11)
########################################################################


@accepts(str, str, str)
def skip_fn(thing: str, fn: str, params_t: str) -> bool:
    if (
        fn.endswith("_no_checks")
        or "initializer_list" in params_t
        or fn.startswith("cend")
        or fn.startswith("end")
        or fn.startswith("begin")  # use cbegin instead
        or fn in ("operator=", "operator[]", "operator<<", "operator()")
        or "&&" in params_t
        or ("*" in params_t and params_t.strip() != "bool(*)()")
        or "*" in return_type(thing, fn, params_t)
        or is_typedef(thing, fn, params_t)
    ):
        return True
    try:
        get_xml(thing, fn, params_t)
    except KeyError:
        return True
    return is_deleted_mem_fn(thing, fn, params_t) or not is_public(thing, fn, params_t)


########################################################################
# Template / Non-template structure
########################################################################


def template_header(thing: str, template_p: list[str]) -> str:
    pack = ", ".join(template_p)
    alias = ", ".join([x.split(" ")[1] for x in template_p if x != "typename"])
    return f"""namespace {{

template <typename TType>
void bind_TODO_common(jl::Module &                  m,
                      jlcxx::TypeWrapper<TType> & type,
                      std::string const &           type_name)
{{
  using Scalar = typename TType::point_type; // TODO: adjust alias

"""


@accepts()
def non_template_header() -> str:
    return """void define_TODO(jl::Module & m)
{
  using namespace libsemigroups;

"""


__TEMPLATE_FOOTER = """}    // bind_TODO_common

template <typename TType>
void bind_TODO_type(jl::Module & m, std::string const & name)
{
  auto type = m.add_type<TType>(name);
  bind_TODO_common(m, type, name);
}

}    // namespace

void define_TODO(jl::Module & m)
{
  using namespace libsemigroups;
  // TODO: add instantiations, e.g.:
  // bind_TODO_type<ClassName<0, uint8_t>>(m, "ClassName1");
  // bind_TODO_type<ClassName<0, uint16_t>>(m, "ClassName2");
  // bind_TODO_type<ClassName<0, uint32_t>>(m, "ClassName4");
}
"""

__NON_TEMPLATE_FOOTER = """}    // define_TODO
"""


########################################################################
# Orchestrator
########################################################################


@accepts(str)
def generate(thing: str) -> str:
    if len(doxygen_filename(thing)) == 0:
        return ""
    get_xml(thing)  # ensure is_abstract_class is initialised
    out = ""
    if not is_namespace(thing) and not is_free_fn(thing):
        if not is_class_template(thing):
            out += jlcxx_type_decl(thing)
        out += "\n"
    fns = get_xml(thing)
    for fn, overloads in fns.items():
        for param_types in overloads:
            if not isinstance(fn, str) or skip_fn(thing, fn, param_types):
                continue
            out += jlcxx_fn(thing, fn, param_types)
    return out


########################################################################
# main
########################################################################


def main():
    if sys.version_info[0] < 3:
        raise Exception("Python 3 is required")
    args = __parse_args()

    if not args.no_header_footer:
        print(__COPYRIGHT)
        print(__HEADERS)

    # Print IsMirroredType specializations before namespace
    for thing in args.things:
        if not is_namespace(thing) and not is_free_fn(thing):
            mirrored = jlcxx_is_mirrored_type(thing)
            if mirrored:
                print(mirrored)

    print("namespace libsemigroups_julia {\n")

    for thing in args.things:
        template_p = class_template_params(thing)
        if len(template_p) != 0:
            print(template_header(thing, template_p))
        else:
            print(non_template_header())

        print(generate(thing))

        if len(template_p) != 0:
            print(__TEMPLATE_FOOTER)
        else:
            print(__NON_TEMPLATE_FOOTER)

    print(__FOOTER)

    if not args.no_advice:
        __bold(
            """
Things to do to include the generated code in libsemigroups_julia:

1. Save output to deps/src/<name>.cpp

2. Rename define_TODO / bind_TODO to define_<name> / bind_<name>

3. Verify the IsMirroredType specialization is correct (for non-template types)

4. Forward-declare define_<name> in deps/src/libsemigroups_julia.hpp

5. Call define_<name>(mod) in deps/src/libsemigroups_julia.cpp

6. Add the .cpp file to add_library() in deps/src/CMakeLists.txt

7. Create Julia wrappers in src/libsemigroups/<name>.jl and src/elements/<name>.jl

8. Add tests in test/test_<name>.jl
"""
        )


if __name__ == "__main__":
    main()
