var documenterSearchIndex = {"docs":
[{"location":"data-structures/elements/#Elements","page":"Overview","title":"Elements","text":"This section contains documentation for defining elements of semigroups in Semigroups.jl.","category":"section"},{"location":"data-structures/elements/#Contents","page":"Overview","title":"Contents","text":"Transformations - Full transformations, partial permutations, and permutations","category":"section"},{"location":"data-structures/elements/transformations/perm/#The-Perm-Type","page":"Perm","title":"The Perm Type","text":"A permutation f is an injective transformation defined on the whole of 1 2 ldots n for some integer n called the degree of f. A permutation is stored as a vector of the images of 1 2 ldots n, i.e. ((1)f (2)f ldots (n)f).","category":"section"},{"location":"data-structures/elements/transformations/perm/#Contents","page":"Perm","title":"Contents","text":"Function Description\nPerm Construct a permutation\np[i] Get the image of a point\ndegree The degree of the permutation\nrank The number of distinct image values\nimage The sorted set of image values\ndomain The sorted set of defined points\ninverse The inverse permutation\none The identity permutation\ncopy Copy a permutation\np * q Compose two permutations\n==, <, <=, >, >= Comparison operators","category":"section"},{"location":"data-structures/elements/transformations/perm/#Full-API","page":"Perm","title":"Full API","text":"","category":"section"},{"location":"data-structures/elements/transformations/perm/#Construction","page":"Perm","title":"Construction","text":"using Semigroups\n\n# From a vector of images (must be a bijection)\np = Perm([2, 3, 1])  # maps 1->2, 2->3, 3->1\np[1]  # 2\n\n# The degree is inferred from the length\ndegree(p)  # 3","category":"section"},{"location":"data-structures/elements/transformations/perm/#Inverse","page":"Perm","title":"Inverse","text":"p = Perm([2, 3, 1])\nq = inverse(p)       # Perm([3, 1, 2])\np * inverse(p) == one(Perm, 3)  # true","category":"section"},{"location":"data-structures/elements/transformations/perm/#Composition","page":"Perm","title":"Composition","text":"Permutations can be composed using *:\n\np = Perm([2, 3, 1])\nq = Perm([3, 1, 2])\nr = p * q  # Perm([1, 2, 3]) — the identity","category":"section"},{"location":"data-structures/elements/transformations/perm/#Comparison","page":"Perm","title":"Comparison","text":"Permutations support equality and lexicographic ordering:\n\np = Perm([2, 3, 1])\nq = copy(p)\np == q  # true\np < Perm([3, 1, 2])  # true","category":"section"},{"location":"data-structures/elements/transformations/perm/#Semigroups.Perm","page":"Perm","title":"Semigroups.Perm","text":"Perm{T}\n\nPermutations with dynamic degree.\n\nA permutation f is an injective transformation defined on the whole of 1 2 ldots n for some integer n called the degree of f. A permutation is stored as a vector of the images of 1 2 ldots n, i.e. ((1)f (2)f ldots (n)f).\n\nConstruction\n\nusing Semigroups\n\n# From an image list\np = Perm([2, 3, 1])  # maps 1->2, 2->3, 3->1\np[1]  # 2\np[2]  # 3\n\n\n\n\n\n","category":"type"},{"location":"data-structures/elements/transformations/perm/#Semigroups.degree-Tuple{Perm}","page":"Perm","title":"Semigroups.degree","text":"degree(p::Perm) -> Int\n\nReturns the degree of a permutation.\n\nThe degree of a permutation is the number of points used in its definition, which is equal to the size of its underlying container.\n\nExample\n\njulia> using Semigroups\n\njulia> degree(Perm([2, 3, 1]))\n3\n\n\n\n\n\n","category":"method"},{"location":"data-structures/elements/transformations/perm/#Semigroups.domain-Tuple{Perm}","page":"Perm","title":"Semigroups.domain","text":"domain(f::Union{Transf, PPerm, Perm}) -> Vector{Int}\n\nReturn the sorted set of points where a partial transformation is defined.\n\nReturns a vector containing those values i such that i in 1 ldots n where n is the degree of f, and f[i] != UNDEFINED.\n\nComplexity\n\nO(n) where n is the degree of f.\n\nSee also image.\n\nExample\n\njulia> using Semigroups\n\njulia> domain(Transf([2, 2, 1]))\n3-element Vector{Int64}:\n 1\n 2\n 3\n\njulia> domain(PPerm([1, 3], [2, 4], 5))\n2-element Vector{Int64}:\n 1\n 3\n\n\n\n\n\n","category":"method"},{"location":"data-structures/elements/transformations/perm/#Semigroups.image-Tuple{Perm}","page":"Perm","title":"Semigroups.image","text":"image(f::Union{Transf, PPerm, Perm}) -> Vector{Int}\n\nReturn the sorted set of image values of a partial transformation.\n\nReturns a vector containing those values f[i] such that i in 1 ldots n where n is the degree of f, and f[i] != UNDEFINED.\n\nComplexity\n\nO(n log n) where n is the degree of f.\n\nSee also domain.\n\nExample\n\njulia> using Semigroups\n\njulia> image(Transf([2, 2, 1]))\n2-element Vector{Int64}:\n 1\n 2\n\njulia> image(PPerm([1, 3], [2, 4], 5))\n2-element Vector{Int64}:\n 2\n 4\n\n\n\n\n\n","category":"method"},{"location":"data-structures/elements/transformations/perm/#Semigroups.inverse-Tuple{Perm}","page":"Perm","title":"Semigroups.inverse","text":"inverse(p::T) where T<:Union{PPerm,Perm} -> T\n\nReturns the inverse of a partial permutation or permutation.\n\nThis function returns a newly constructed inverse of p. The inverse of a partial permutation p is the partial term g such that fgf = f and gfg =g.\n\nExample\n\njulia> using Semigroups\n\njulia> p = Perm([2, 3, 1]);\n\njulia> inverse(p)\nPerm([3, 1, 2])\n\njulia> p * inverse(p) == one(Perm, 3)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"data-structures/elements/transformations/perm/#Base.one-Tuple{Type{Perm}, Int64}","page":"Perm","title":"Base.one","text":"Base.one(::Type{Perm}, n::Integer) -> Perm\n\nReturns the identity permutation on n points.\n\nThis function returns a newly constructed permutation with degree equal to n that fixes every value from 1 to n.\n\nExample\n\njulia> using Semigroups\n\njulia> one(Perm, 3)\nPerm([1, 2, 3])\n\n\n\n\n\n","category":"method"},{"location":"data-structures/elements/transformations/perm/#Semigroups.rank-Tuple{Perm}","page":"Perm","title":"Semigroups.rank","text":"rank(p::Perm) -> Int\n\nReturns the number of distinct image values of a permutation.\n\nThe rank of a permutation is the number of its distinct image values, not including UNDEFINED.\n\nExample\n\njulia> using Semigroups\n\njulia> rank(Perm([2, 3, 1]))\n3\n\nComplexity\n\nLinear in degree()\n\n\n\n\n\n","category":"method"},{"location":"main-algorithms/#Overview","page":"Overview","title":"Overview","text":"This section will document the main algorithms available in Semigroups.jl.","category":"section"},{"location":"main-algorithms/#Planned-Algorithms","page":"Overview","title":"Planned Algorithms","text":"The following algorithms from libsemigroups will be exposed through Semigroups.jl:","category":"section"},{"location":"main-algorithms/#Froidure-Pin-Algorithm","page":"Overview","title":"Froidure-Pin Algorithm","text":"","category":"section"},{"location":"main-algorithms/#Knuth-Bendix-Completion","page":"Overview","title":"Knuth-Bendix Completion","text":"","category":"section"},{"location":"main-algorithms/#Todd-Coxeter-Algorithm","page":"Overview","title":"Todd-Coxeter Algorithm","text":"","category":"section"},{"location":"main-algorithms/#Schreier-Sims-Algorithm","page":"Overview","title":"Schreier-Sims Algorithm","text":"","category":"section"},{"location":"main-algorithms/#Status","page":"Overview","title":"Status","text":"This section is under development.","category":"section"},{"location":"package-info/authors/#Authors","page":"Authors","title":"Authors","text":"James W. Swent\nJames D. Mitchell","category":"section"},{"location":"package-info/authors/#Contributors","page":"Authors","title":"Contributors","text":"Joseph Edwards contributed to the CI pipeline.","category":"section"},{"location":"data-structures/elements/transformations/transf/#The-Transf-Type","page":"Transf","title":"The Transf Type","text":"A transformation f is just a function defined on the whole of 1 2 ldots n for some integer n called the degree of f. A transformation is stored as a vector of the images of 1 2 ldots n, i.e. ((1)f (2)f ldots (n)f).","category":"section"},{"location":"data-structures/elements/transformations/transf/#Contents","page":"Transf","title":"Contents","text":"Function Description\nTransf Construct a transformation\nt[i] Get the image of a point\ndegree The degree of the transformation\nrank The number of distinct image values\nimage The sorted set of image values\ndomain The sorted set of defined points\none The identity transformation\ncopy Copy a transformation\nt * s Compose two transformations\n==, <, <=, >, >= Comparison operators","category":"section"},{"location":"data-structures/elements/transformations/transf/#Full-API","page":"Transf","title":"Full API","text":"","category":"section"},{"location":"data-structures/elements/transformations/transf/#Construction","page":"Transf","title":"Construction","text":"using Semigroups\n\n# From a vector of images\nt = Transf([2, 3, 1, 4])  # maps 1->2, 2->3, 3->1, 4->4\nt[1]  # 2\n\n# The degree is inferred from the length\ndegree(t)  # 4","category":"section"},{"location":"data-structures/elements/transformations/transf/#Composition","page":"Transf","title":"Composition","text":"Transformations can be composed using *:\n\ns = Transf([2, 1, 3])\nt = Transf([3, 2, 1])\ns * t  # apply s first, then t","category":"section"},{"location":"data-structures/elements/transformations/transf/#Comparison","page":"Transf","title":"Comparison","text":"Transformations support equality and lexicographic ordering:\n\nt = Transf([2, 3, 1])\ns = copy(t)\nt == s  # true\nt < Transf([3, 2, 1])  # true","category":"section"},{"location":"data-structures/elements/transformations/transf/#Semigroups.Transf","page":"Transf","title":"Semigroups.Transf","text":"Transf{T}\n\nTransformations with dynamic degree.\n\nA transformation f is just a function defined on the whole of 1 2 ldots n for some integer n called the degree of f. A transformation is stored as a vector of the images of 1 2 ldots n, i.e. ((1)f (2)f ldots (n)f).\n\nConstruction\n\nusing Semigroups\n\n# From an image list\nt = Transf([2, 1, 2, 3])  # maps 1->2, 2->1, 3->2, 4->3\nt[1]  # 2\nt[3]  # 2\n\n\n\n\n\n","category":"type"},{"location":"data-structures/elements/transformations/transf/#Semigroups.degree-Tuple{Transf}","page":"Transf","title":"Semigroups.degree","text":"degree(t::Transf) -> Int\n\nReturns the degree of a transformation.\n\nThe degree of a transformation is the number of points used in its definition, which is equal to the size of its underlying container.\n\nExample\n\njulia> using Semigroups\n\njulia> t = Transf([2, 3, 1, 4]);\n\njulia> degree(t)\n4\n\n\n\n\n\n","category":"method"},{"location":"data-structures/elements/transformations/transf/#Semigroups.domain-Tuple{Transf}","page":"Transf","title":"Semigroups.domain","text":"domain(f::Union{Transf, PPerm, Perm}) -> Vector{Int}\n\nReturn the sorted set of points where a partial transformation is defined.\n\nReturns a vector containing those values i such that i in 1 ldots n where n is the degree of f, and f[i] != UNDEFINED.\n\nComplexity\n\nO(n) where n is the degree of f.\n\nSee also image.\n\nExample\n\njulia> using Semigroups\n\njulia> domain(Transf([2, 2, 1]))\n3-element Vector{Int64}:\n 1\n 2\n 3\n\njulia> domain(PPerm([1, 3], [2, 4], 5))\n2-element Vector{Int64}:\n 1\n 3\n\n\n\n\n\n","category":"method"},{"location":"data-structures/elements/transformations/transf/#Semigroups.image-Tuple{Transf}","page":"Transf","title":"Semigroups.image","text":"image(f::Union{Transf, PPerm, Perm}) -> Vector{Int}\n\nReturn the sorted set of image values of a partial transformation.\n\nReturns a vector containing those values f[i] such that i in 1 ldots n where n is the degree of f, and f[i] != UNDEFINED.\n\nComplexity\n\nO(n log n) where n is the degree of f.\n\nSee also domain.\n\nExample\n\njulia> using Semigroups\n\njulia> image(Transf([2, 2, 1]))\n2-element Vector{Int64}:\n 1\n 2\n\njulia> image(PPerm([1, 3], [2, 4], 5))\n2-element Vector{Int64}:\n 2\n 4\n\n\n\n\n\n","category":"method"},{"location":"data-structures/elements/transformations/transf/#Base.one-Tuple{Type{Transf}, Int64}","page":"Transf","title":"Base.one","text":"Base.one(::Type{Transf}, n::Integer) -> Transf\n\nReturns the identity transformation on n points.\n\nThis function returns a newly constructed transformation with degree equal to n that fixes every value from 1 to n.\n\nExample\n\njulia> using Semigroups\n\njulia> one(Transf, 3)\nTransf([1, 2, 3])\n\n\n\n\n\n","category":"method"},{"location":"data-structures/elements/transformations/transf/#Semigroups.rank-Tuple{Transf}","page":"Transf","title":"Semigroups.rank","text":"rank(t::Transf) -> Int\n\nReturns the number of distinct image values of a transformation.\n\nThe rank of a transformation is the number of its distinct image values.\n\nExample\n\njulia> using Semigroups\n\njulia> rank(Transf([1, 1, 1]))\n1\n\njulia> rank(Transf([2, 3, 1]))\n3\n\nComplexity\n\nLinear in degree()\n\n\n\n\n\n","category":"method"},{"location":"package-info/exceptions/#Exceptions","page":"Exceptions","title":"Exceptions","text":"","category":"section"},{"location":"package-info/exceptions/#Semigroups.Errors.LibsemigroupsError","page":"Exceptions","title":"Semigroups.Errors.LibsemigroupsError","text":"LibsemigroupsError <: Exception\n\nException type for errors originating from the libsemigroups C++ library. The error message has the C++ source location prefix stripped but is otherwise unchanged (including 0-based indexing).\n\n\n\n\n\n","category":"type"},{"location":"package-info/exceptions/#Semigroups.Errors.@wrap_libsemigroups_call","page":"Exceptions","title":"Semigroups.Errors.@wrap_libsemigroups_call","text":"@wrap_libsemigroups_call(expr)\n\nWrap a libsemigroups C++ call to catch exceptions and rethrow them as LibsemigroupsError with the C++ prefix stripped.\n\nwarning: Warning\nError messages originate from the C++ library and use 0-based indexing for positions and values.\n\nExample\n\ncxx_obj = @wrap_libsemigroups_call begin\n    CxxType(StdVector(images_typed))\nend\n\n\n\n\n\n","category":"macro"},{"location":"package-info/installation/#Installation","page":"Installation","title":"Installation","text":"","category":"section"},{"location":"package-info/installation/#Requirements","page":"Installation","title":"Requirements","text":"Julia 1.9 or later\nCMake 3.15 or later (for building C++ bindings)\nA C++17 compatible compiler","category":"section"},{"location":"package-info/installation/#Installing-from-Source","page":"Installation","title":"Installing from Source","text":"Currently, Semigroups.jl must be installed from source:\n\nusing Pkg\nPkg.add(url=\"https://github.com/libsemigroups/Semigroups.jl\")","category":"section"},{"location":"package-info/installation/#Building-the-C-Bindings","page":"Installation","title":"Building the C++ Bindings","text":"The package automatically builds the required C++ bindings during installation. If you need to rebuild manually:\n\nusing Pkg\nPkg.build(\"Semigroups\")","category":"section"},{"location":"package-info/installation/#Verifying-Installation","page":"Installation","title":"Verifying Installation","text":"using Semigroups\n\n# Test basic functionality\nt = Transf([2, 1])\nprintln(degree(t))  # Should print 2","category":"section"},{"location":"package-info/installation/#Troubleshooting","page":"Installation","title":"Troubleshooting","text":"","category":"section"},{"location":"package-info/installation/#Library-Loading-Errors","page":"Installation","title":"Library Loading Errors","text":"If you encounter errors loading the shared library, ensure:\n\nCMake is installed and available in your PATH\nYou have a C++17 compatible compiler (GCC 7+, Clang 5+, or MSVC 2017+)\nThe libsemigroups library is accessible","category":"section"},{"location":"package-info/installation/#Build-Failures","page":"Installation","title":"Build Failures","text":"For build issues, try:\n\nusing Pkg\nPkg.build(\"Semigroups\"; verbose=true)\n\nThis will show detailed build output to help diagnose problems.","category":"section"},{"location":"data-structures/elements/transformations/pperm/#The-PPerm-Type","page":"PPerm","title":"The PPerm Type","text":"A partial permutation f is an injective partial transformation, which is stored as the vector of images of 12ldotsn, i.e. ((1)f(2)fldots(n)f) where the value UNDEFINED is used to indicate that (i)f is undefined (i.e. not among the points where f is defined).","category":"section"},{"location":"data-structures/elements/transformations/pperm/#Contents","page":"PPerm","title":"Contents","text":"Function Description\nPPerm Construct a partial permutation\np[i] Get the image of a point (returns UNDEFINED if not in the domain)\ndegree The degree of the partial permutation\nrank The number of distinct image values, not including UNDEFINED\nimage The sorted set of image values\ndomain The sorted set of points where f is defined\ninverse The inverse partial permutation\nleft_one The identity on the domain\none The identity partial permutation of the same degree\nright_one The identity on the image\ncopy Copy a partial permutation\np * q Compose two partial permutations\n==, <, <=, >, >= Comparison operators","category":"section"},{"location":"data-structures/elements/transformations/pperm/#Full-API","page":"PPerm","title":"Full API","text":"","category":"section"},{"location":"data-structures/elements/transformations/pperm/#Construction","page":"PPerm","title":"Construction","text":"using Semigroups\n\n# From a vector of images (use UNDEFINED for undefined points)\np = PPerm([3, 4, UNDEFINED, UNDEFINED, UNDEFINED])\np[1]  # 3\np[3]  # UNDEFINED\n\n# From domain, range, and degree\np = PPerm([1, 2], [3, 4], 5)  # 1 -> 3, 2 -> 4, degree 5","category":"section"},{"location":"data-structures/elements/transformations/pperm/#Inverse","page":"PPerm","title":"Inverse","text":"p = PPerm([1, 2], [3, 4], 5)\nq = inv(p)           # maps 3 -> 1, 4 -> 2\np * inv(p) == left_one(p)   # true\ninv(p) * p == right_one(p)  # true","category":"section"},{"location":"data-structures/elements/transformations/pperm/#Left-and-Right-Ones","page":"PPerm","title":"Left and Right Ones","text":"p = PPerm([1, 3], [2, 4], 4)\nleft_one(p) * p == p   # true\np * right_one(p) == p  # true","category":"section"},{"location":"data-structures/elements/transformations/pperm/#Composition","page":"PPerm","title":"Composition","text":"Partial permutations can be composed using *:\n\np = PPerm([1, 2], [3, 4], 5)\nq = PPerm([3, 4], [5, 1], 5)\nr = p * q  # 1 -> 5, 2 -> 1","category":"section"},{"location":"data-structures/elements/transformations/pperm/#Comparison","page":"PPerm","title":"Comparison","text":"Partial permutations support equality and lexicographic ordering:\n\np = PPerm([1, 2], [3, 4], 5)\nq = copy(p)\np == q  # true\np < PPerm([1, 2], [4, 3], 5)  # true","category":"section"},{"location":"data-structures/elements/transformations/pperm/#Semigroups.PPerm","page":"PPerm","title":"Semigroups.PPerm","text":"PPerm{T}\n\nPartial permutations with dynamic degree.\n\nA partial permutation f is just an injective partial transformation, which is stored as a vector of the images of 1 2 ldots n, i.e. ((1)f (2)f ldots (n)f) where the value UNDEFINED is used to indicate that (i)f is undefined (i.e. not among the points where f is defined).\n\nConstruction\n\nusing Semigroups\n\n# From an image list (use UNDEFINED for undefined points)\np = PPerm([2, UNDEFINED, 1])\np[1]  # 2\np[2]  # UNDEFINED\n\n# From domain, image, and degree\np = PPerm([1, 3], [2, 1], 3)  # 1 -> 2, 3 -> 1, degree 3\n\n\n\n\n\n","category":"type"},{"location":"data-structures/elements/transformations/pperm/#Semigroups.degree-Tuple{PPerm}","page":"PPerm","title":"Semigroups.degree","text":"degree(p::PPerm) -> Int\n\nReturns the degree of a partial permutation.\n\nThe degree of a partial permutation is the number of points used in its definition, which is equal to the size of its underlying container.\n\nExample\n\njulia> using Semigroups\n\njulia> degree(PPerm([1, 3], [2, 4], 5))\n5\n\n\n\n\n\n","category":"method"},{"location":"data-structures/elements/transformations/pperm/#Semigroups.domain-Tuple{PPerm}","page":"PPerm","title":"Semigroups.domain","text":"domain(f::Union{Transf, PPerm, Perm}) -> Vector{Int}\n\nReturn the sorted set of points where a partial transformation is defined.\n\nReturns a vector containing those values i such that i in 1 ldots n where n is the degree of f, and f[i] != UNDEFINED.\n\nComplexity\n\nO(n) where n is the degree of f.\n\nSee also image.\n\nExample\n\njulia> using Semigroups\n\njulia> domain(Transf([2, 2, 1]))\n3-element Vector{Int64}:\n 1\n 2\n 3\n\njulia> domain(PPerm([1, 3], [2, 4], 5))\n2-element Vector{Int64}:\n 1\n 3\n\n\n\n\n\n","category":"method"},{"location":"data-structures/elements/transformations/pperm/#Semigroups.image-Tuple{PPerm}","page":"PPerm","title":"Semigroups.image","text":"image(f::Union{Transf, PPerm, Perm}) -> Vector{Int}\n\nReturn the sorted set of image values of a partial transformation.\n\nReturns a vector containing those values f[i] such that i in 1 ldots n where n is the degree of f, and f[i] != UNDEFINED.\n\nComplexity\n\nO(n log n) where n is the degree of f.\n\nSee also domain.\n\nExample\n\njulia> using Semigroups\n\njulia> image(Transf([2, 2, 1]))\n2-element Vector{Int64}:\n 1\n 2\n\njulia> image(PPerm([1, 3], [2, 4], 5))\n2-element Vector{Int64}:\n 2\n 4\n\n\n\n\n\n","category":"method"},{"location":"data-structures/elements/transformations/pperm/#Semigroups.inverse-Tuple{PPerm}","page":"PPerm","title":"Semigroups.inverse","text":"inverse(p::T) where T<:Union{PPerm,Perm} -> T\n\nReturns the inverse of a partial permutation or permutation.\n\nThis function returns a newly constructed inverse of p. The inverse of a partial permutation p is the partial term g such that fgf = f and gfg =g.\n\nExample\n\njulia> using Semigroups\n\njulia> p = Perm([2, 3, 1]);\n\njulia> inverse(p)\nPerm([3, 1, 2])\n\njulia> p * inverse(p) == one(Perm, 3)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"data-structures/elements/transformations/pperm/#Semigroups.left_one-Tuple{PPerm}","page":"PPerm","title":"Semigroups.left_one","text":"left_one(p::PPerm) -> PPerm\n\nReturns the left one of a partial permutation.\n\nThis function returns a newly constructed partial permutation with degree equal to that of p that fixes every value in the domain of p, and is UNDEFINED on any other values.\n\nExample\n\njulia> using Semigroups\n\njulia> p = PPerm([1, 3], [2, 4], 4);\n\njulia> left_one(p) * p == p\ntrue\n\n\n\n\n\n","category":"method"},{"location":"data-structures/elements/transformations/pperm/#Base.one-Tuple{PPerm}","page":"PPerm","title":"Base.one","text":"Base.one(p::T) where T<:Union{Transf,PPerm,Perm} -> T\n\nReturns the identity on the same number of points as the degree of p.\n\nThis function returns a newly constructed object of the same type as p that fixes every value from 1 to degree(p).\n\nExample\n\njulia> using Semigroups\n\njulia> p = Perm([2, 3, 1]);\n\njulia> one(p)\nPerm([1, 2, 3])\n\njulia> p * one(p) == p\ntrue\n\n\n\n\n\n","category":"method"},{"location":"data-structures/elements/transformations/pperm/#Base.one-Tuple{Type{PPerm}, Int64}","page":"PPerm","title":"Base.one","text":"Base.one(::Type{PPerm}, n::Integer) -> PPerm\n\nReturns the identity partial permutation on n points.\n\nThis function returns a newly constructed partial permutation with degree equal to n that fixes every value from 1 to n.\n\nExample\n\njulia> using Semigroups\n\njulia> one(PPerm, 3)\nPPerm([1, 2, 3], [1, 2, 3], 3)\n\n\n\n\n\n","category":"method"},{"location":"data-structures/elements/transformations/pperm/#Semigroups.right_one-Tuple{PPerm}","page":"PPerm","title":"Semigroups.right_one","text":"right_one(p::PPerm) -> PPerm\n\nReturns the right one of a partial permutation.\n\nThis function returns a newly constructed partial permutation with degree equal to that of p that fixes every value in the image of p, and is UNDEFINED on any other values.\n\nExample\n\njulia> using Semigroups\n\njulia> p = PPerm([1, 3], [2, 4], 4);\n\njulia> p * right_one(p) == p\ntrue\n\n\n\n\n\n","category":"method"},{"location":"data-structures/elements/transformations/pperm/#Semigroups.rank-Tuple{PPerm}","page":"PPerm","title":"Semigroups.rank","text":"rank(p::PPerm) -> Int\n\nReturns the number of distinct image values in a partial permutation.\n\nThe rank of a partial permutation is the number of its distinct image values, not including UNDEFINED.\n\nExample\n\njulia> using Semigroups\n\njulia> rank(PPerm([1, 3], [2, 4], 5))\n2\n\nComplexity\n\nLinear in degree()\n\n\n\n\n\n","category":"method"},{"location":"data-structures/elements/transformations/#Transformations","page":"Overview","title":"Transformations","text":"A partial transformation f is just a function defined on a subset of 1 2 ldots n for some integer n called the degree of f. A partial transformation is stored as a vector of the images of 1 2 ldots n, i.e. ((1)f (2)f ldots (n)f) where the value UNDEFINED is used to indicate that (i)f is undefined (i.e. not among the points where f is defined).","category":"section"},{"location":"data-structures/elements/transformations/#Types","page":"Overview","title":"Types","text":"The following concrete types of partial transformation are available:\n\nType Description\nTransf A transformation: a function on the whole of 1 ldots n\nPPerm A partial permutation: an injective partial transformation\nPerm A permutation: an injective transformation on the whole of 1 ldots n\n\nThese types form a natural hierarchy: every Perm is a Transf, and every Transf is a special case of a partial transformation (one where every point has an image). A PPerm is a partial transformation that is additionally injective.\n\nFull documentation for each type and its relevant functions can be found on its corresponding page:\n\nPages = [\n    \"transf.md\",\n    \"pperm.md\",\n    \"perm.md\",\n]\nDepth = 1","category":"section"},{"location":"data-structures/elements/transformations/#Automatic-scalar-type-selection","page":"Overview","title":"Automatic scalar type selection","text":"Each type is parametric, Transf{T}, PPerm{T}, and Perm{T}, where T is an unsigned integer type (UInt8, UInt16, or UInt32) used to store image values. When constructed without an explicit type parameter, the smallest sufficient scalar type is chosen automatically based on the degree:\n\nDegree Scalar type\n1 to 255 UInt8\n256 to 65535 UInt16\ngeq 65536 UInt32","category":"section"},{"location":"data-structures/elements/transformations/#Indexing-convention","page":"Overview","title":"Indexing convention","text":"All transformation types use 1-based indexing (the standard Julia convention). Internally, indices are converted to 0-based for the underlying C++ library (libsemigroups).","category":"section"},{"location":"data-structures/elements/transformations/#Full-API-—-shared-functions","page":"Overview","title":"Full API — shared functions","text":"","category":"section"},{"location":"data-structures/elements/transformations/#Base.copy-Tuple{Transf}","page":"Overview","title":"Base.copy","text":"Base.copy(t::Transf) -> Transf\n\nCreate an independent copy of transformation t.\n\nExample\n\njulia> using Semigroups\n\njulia> t = Transf([2, 3, 1]);\n\njulia> s = copy(t);\n\njulia> t == s\ntrue\n\n\n\n\n\nBase.copy(p::PPerm) -> PPerm\n\nCreate an independent copy of partial permutation p.\n\nExample\n\njulia> using Semigroups\n\njulia> p = PPerm([1, 3], [2, 4], 5);\n\njulia> q = copy(p);\n\njulia> p == q\ntrue\n\n\n\n\n\nBase.copy(p::Perm) -> Perm\n\nCreate an independent copy of permutation p.\n\nExample\n\njulia> using Semigroups\n\njulia> p = Perm([2, 3, 1]);\n\njulia> q = copy(p);\n\njulia> p == q\ntrue\n\n\n\n\n\n","category":"method"},{"location":"data-structures/elements/transformations/#Semigroups.domain-Tuple{Union{PPerm, Perm, Transf}}","page":"Overview","title":"Semigroups.domain","text":"domain(f::Union{Transf, PPerm, Perm}) -> Vector{Int}\n\nReturn the sorted set of points where a partial transformation is defined.\n\nReturns a vector containing those values i such that i in 1 ldots n where n is the degree of f, and f[i] != UNDEFINED.\n\nComplexity\n\nO(n) where n is the degree of f.\n\nSee also image.\n\nExample\n\njulia> using Semigroups\n\njulia> domain(Transf([2, 2, 1]))\n3-element Vector{Int64}:\n 1\n 2\n 3\n\njulia> domain(PPerm([1, 3], [2, 4], 5))\n2-element Vector{Int64}:\n 1\n 3\n\n\n\n\n\n","category":"method"},{"location":"data-structures/elements/transformations/#Semigroups.image-Tuple{Union{PPerm, Perm, Transf}}","page":"Overview","title":"Semigroups.image","text":"image(f::Union{Transf, PPerm, Perm}) -> Vector{Int}\n\nReturn the sorted set of image values of a partial transformation.\n\nReturns a vector containing those values f[i] such that i in 1 ldots n where n is the degree of f, and f[i] != UNDEFINED.\n\nComplexity\n\nO(n log n) where n is the degree of f.\n\nSee also domain.\n\nExample\n\njulia> using Semigroups\n\njulia> image(Transf([2, 2, 1]))\n2-element Vector{Int64}:\n 1\n 2\n\njulia> image(PPerm([1, 3], [2, 4], 5))\n2-element Vector{Int64}:\n 2\n 4\n\n\n\n\n\n","category":"method"},{"location":"data-structures/elements/transformations/#Semigroups.increase_degree_by!-Tuple{Union{PPerm, Perm, Transf}, Integer}","page":"Overview","title":"Semigroups.increase_degree_by!","text":"increase_degree_by!(t::Union{Transf,PPerm,Perm}, n::Integer)\n\nIncrease the degree of transformation t by n points. Modifies t in place, leaving existing values unaltered.\n\nExample\n\njulia> using Semigroups\n\njulia> t = Transf([1, 2]);\n\njulia> increase_degree_by!(t, 3);\n\njulia> degree(t)\n5\n\n\n\n\n\n","category":"method"},{"location":"data-structures/elements/transformations/#Semigroups.swap!-Union{Tuple{T}, Tuple{T, T}} where T<:Union{PPerm, Perm, Transf}","page":"Overview","title":"Semigroups.swap!","text":"swap!(t1::T, t2::T) where T<:Union{Transf,PPerm,Perm}\n\nSwap the contents of transformations t1 and t2. Both objects are modified.\n\nExample\n\nt1 = Transf([1, 2])\nt2 = Transf([2, 1, 3])\nswap!(t1, t2)  # t1 and t2 have exchanged contents\n\n\n\n\n\n","category":"method"},{"location":"data-structures/constants/#Constants","page":"Constants","title":"Constants","text":"This page describes the constants used in Semigroups.jl.","category":"section"},{"location":"data-structures/constants/#Constant-Values","page":"Constants","title":"Constant Values","text":"","category":"section"},{"location":"data-structures/constants/#Predicate-Functions","page":"Constants","title":"Predicate Functions","text":"","category":"section"},{"location":"data-structures/constants/#Ternary-Logic-(tril)","page":"Constants","title":"Ternary Logic (tril)","text":"","category":"section"},{"location":"data-structures/constants/#Semigroups.UNDEFINED","page":"Constants","title":"Semigroups.UNDEFINED","text":"UNDEFINED\n\nValue for something undefined.\n\nThis variable is used to indicate that a value is undefined. UNDEFINED is comparable with any value via == and != but not via < or >.\n\nExamples\n\nusing Semigroups\n\np = PPerm([2, UNDEFINED, 1])\np[2]  # UNDEFINED\np[2] == UNDEFINED  # true\np[1] == UNDEFINED  # false\n\n\n\n\n\n","category":"constant"},{"location":"data-structures/constants/#Semigroups.POSITIVE_INFINITY","page":"Constants","title":"Semigroups.POSITIVE_INFINITY","text":"POSITIVE_INFINITY\n\nRepresents positive infinity in libsemigroups. Can be compared with integers and NEGATIVE_INFINITY using <, >, ==, !=. Converts to max-1 of the target integer type.\n\n\n\n\n\n","category":"constant"},{"location":"data-structures/constants/#Semigroups.NEGATIVE_INFINITY","page":"Constants","title":"Semigroups.NEGATIVE_INFINITY","text":"NEGATIVE_INFINITY\n\nRepresents negative infinity in libsemigroups. Can be compared with signed integers and POSITIVE_INFINITY using <, >, ==, !=. Converts to the minimum value of the target signed integer type.\n\n\n\n\n\n","category":"constant"},{"location":"data-structures/constants/#Semigroups.LIMIT_MAX","page":"Constants","title":"Semigroups.LIMIT_MAX","text":"LIMIT_MAX\n\nRepresents the maximum limit value in libsemigroups. Converts to max-2 of the target integer type.\n\n\n\n\n\n","category":"constant"},{"location":"data-structures/constants/#Semigroups.is_undefined","page":"Constants","title":"Semigroups.is_undefined","text":"is_undefined(x) -> Bool\n\nReturn true if x is UNDEFINED, false otherwise.\n\nExamples\n\nusing Semigroups\n\np = PPerm([2, UNDEFINED, 1])\nis_undefined(p[2])  # true\nis_undefined(p[1])  # false\n\n\n\n\n\n","category":"function"},{"location":"data-structures/constants/#Semigroups.is_positive_infinity","page":"Constants","title":"Semigroups.is_positive_infinity","text":"is_positive_infinity(x::Integer, T::Type = typeof(x))\n\nCheck if x equals POSITIVE_INFINITY for the given integer type T.\n\n\n\n\n\n","category":"function"},{"location":"data-structures/constants/#Semigroups.is_negative_infinity","page":"Constants","title":"Semigroups.is_negative_infinity","text":"is_negative_infinity(x::Integer, T::Type = typeof(x))\n\nCheck if x equals NEGATIVE_INFINITY for the given signed integer type T.\n\n\n\n\n\n","category":"function"},{"location":"data-structures/constants/#Semigroups.is_limit_max","page":"Constants","title":"Semigroups.is_limit_max","text":"is_limit_max(x::Integer, T::Type = typeof(x))\n\nCheck if x equals LIMIT_MAX for the given integer type T.\n\n\n\n\n\n","category":"function"},{"location":"data-structures/constants/#Semigroups.tril","page":"Constants","title":"Semigroups.tril","text":"tril\n\nTernary logic type representing true, false, or unknown values. Use tril_TRUE, tril_FALSE, and tril_unknown for the possible values.\n\n\n\n\n\n","category":"type"},{"location":"data-structures/constants/#Semigroups.tril_TRUE","page":"Constants","title":"Semigroups.tril_TRUE","text":"tril_TRUE\n\nThe true value of the ternary logic type tril.\n\n\n\n\n\n","category":"constant"},{"location":"data-structures/constants/#Semigroups.tril_FALSE","page":"Constants","title":"Semigroups.tril_FALSE","text":"tril_FALSE\n\nThe false value of the ternary logic type tril.\n\n\n\n\n\n","category":"constant"},{"location":"data-structures/constants/#Semigroups.tril_unknown","page":"Constants","title":"Semigroups.tril_unknown","text":"tril_unknown\n\nThe unknown value of the ternary logic type tril.\n\n\n\n\n\n","category":"constant"},{"location":"data-structures/constants/#Semigroups.tril_to_bool","page":"Constants","title":"Semigroups.tril_to_bool","text":"tril_to_bool(t::tril) -> Union{Bool, Nothing}\n\nConvert a tril value to a Julia Bool or nothing. Returns true for tril_TRUE, false for tril_FALSE, and nothing for tril_unknown.\n\n\n\n\n\n","category":"function"},{"location":"#Semigroups.jl","page":"Home","title":"Semigroups.jl","text":"Julia bindings for the libsemigroups C++ library.","category":"section"},{"location":"#Overview","page":"Home","title":"Overview","text":"This package is currently in development.","category":"section"},{"location":"#How-to-install-Semigroups.jl?","page":"Home","title":"How to install Semigroups.jl?","text":"To see how to install Semigroups.jl, see the installation page.","category":"section"},{"location":"#See-Also","page":"Home","title":"See Also","text":"libsemigroups documentation\nlibsemigroups on GitHub","category":"section"}]
}
